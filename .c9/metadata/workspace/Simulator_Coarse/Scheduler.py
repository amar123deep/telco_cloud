{"changed":true,"filter":false,"title":"Scheduler.py","tooltip":"/Simulator_Coarse/Scheduler.py","value":"import simpy\nfrom Datacentre import Datacentre\nfrom Link import Link\n\nclass Scheduler(object):\n\t\"\"\"\n\tDeclare global dictionary that will keep track of all the apps and the nodes \n\ton which they are running. Later we plan to assign ID to each application. \n\t\"\"\"\n\tappNodeDictGlobal = {}\n\t\t\n\tdef __init__(self, env, topology, coordinator):\n\t\tself.env = env\n\t\tself.topology = topology\n\t\tself.coordinator = coordinator\n\t\tself.placements = []\n\t\tself.measuredSystemOverload = float('inf')\n\t\tself.placementRegistry = {}\n\t\t\n\t\t#self.monitor.registerSignal( \"PLACEMENTS\" )\n\t\t#self.monitor.registerOutput( [ (\"PLACEMENTS\", SystemMonitor.fileCSVOutput, self.composePlacementsHeader) ] )\n\t\n\tdef recordMeasuredSystemOverload(self, signalName, signalValue):\n\t\tself.measuredSystemOverload = signalValue\n\t\n\tdef recordPlacement(self, appName, dcName, overload):\n\t\tself.placementRegistry[appName] = (dcName, overload)\n\t\t\n\tdef getPlacementHistory(self, appName):\n\t\tif appName in self.placementRegistry:\n\t\t\treturn self.placementRegistry[appName]\n\t\telse:\n\t\t\treturn (None, float('inf'))\n\t\n\tdef addMeasurement(self, data):\n\t\tself.placements.append(data)\n\t\t\n\tdef getPlacementBuffer(self):\n\t\tplacementsBuffer = str()\n\t\t\n\t\tfor placement in self.placements:\n\t\t\tplacementsBuffer += \"%s \\r\" % placement\n\t\t\t\n\t\tself.placements = []\n\t\t\n\t\treturn placementsBuffer\n\t\n\t# [DEPRECATED] What is this for?\n\tdef removeDC(self, AppDCList):\n\t\t'''\n\t\tremoves the list of DCs from the table of the topology\n\t\t'''\n\t\tfor (appName, dcName) in AppDCList:\n\t\t\tdc = self.topology.getNode(dcName)\n\t\t\tdc.terminateApp(appName)\n\t\tself.topology.removeFromTable(AppDCList)\n\t\n\t# [DEPRECATED]  What is this for?\n\tdef addAppLeafNode(self, appNodeDict): \n\t\t\"\"\"\n\t\tDescr : This function should be called when new app appears in the \n\t\t\t\tsystem\n\t\tInput : app and the leaf node where the app should run   \n\t\tOutput: return 1 on success\n\t\t\"\"\"\n\t\toverload = self.getoverloadNodes(appNodeDict)\n\t\t\n\tdef lookupDistH (self,nodeList,dist):\n\t\t\"\"\"\n\t\tDescr : compute all the neighbour for distance less than and equal to dist\n\t\t\t\t\n\t\tInput : distance dist, node list\n\t\t\n\t\t\"\"\"\n\t\tnewDict = {}\n\t\tfor n in nodeList: \n\t\t\tnewDict[n] = self.lookupNeighbour(n,dist)\n\t\t\t\n\t\treturn newDict    \n\t\n\t# [DEPRECATED] What is this for?\n\tdef generateSolutions(self, dist, numNodes): \n\t\t_masterList = []\n\t\tbaseList = [0]*numNodes \n\t\t#while dist <=0:\n\t\tfor i in range(dist):\n\t\t\tbaseList[i] = dist -i \n\t\t\tdist = dist -1\n\t\tpass\n\t\n\t'''\n\t######## Evaluations ########\n\t'''\n\t# Compute total local resource usage for app in appNames and paths \n\tdef evaluateAppPlacementResourcesUsage(self, appPlacement): # appPaths ([PATH], appName, demand)\n\t\tenteties = {}\n\t\tfor (path, appName, demand) in appPlacement:\n\t\t\tfor entity in path:\n\t\t\t\tif entity.getName() not in enteties:\n\t\t\t\t\tenteties[entity.getName()] = {'USAGE':entity.evaluateResourcesUsageExcluding(appName), 'ENTITY':entity}\n\t\t\t\t\n\t\t\t\tusage = entity.evaluateAdditionalResourcesUsage({appName:demand})\n\t\t\t\tfor resourceName, resourceUsage in usage.iteritems():\n\t\t\t\t\tenteties[entity.getName()]['USAGE'][resourceName] += resourceUsage\n\t\t\t\t\t\t\n\t\treturn enteties\n\t\n\t# Evalute if path can accomodate the placement option\n\tdef evaluatePath(self, appPlacement):\n\t\tentities = self.evaluateAppPlacementResourcesUsage(appPlacement)\n\t\t\n\t\tfor entity in entities:\n\t\t\tentity['FITS'] = entity['ENTITY'].willAppFit({appName: entity['USAGE']})\n\t\t\n\t# Evalute if path can accomodate the placement option\n\tdef evaluateAppPlacementOverload(self, appPlacement):\n\t\tentities = self.evaluateAppPlacementResourcesUsage(appPlacement)\n\t\t\n\t\toverloadFactor = 0\n\n\t\tfor entity in entities.itervalues():\n\t\t\tentitiyOverload = entity['ENTITY'].evaluateAggregateOverload(entity['USAGE'])\n\t\t\t\n\t\t\toverloadFactor += entitiyOverload\n\t\t\n\t\treturn overloadFactor\t\n\t\n\tdef getoverloadNodes(self,dictAppNode):\n\t\t\"\"\"\n\t\tDescr : compute the overload of the nodes where the application is \n\t\t\t\trunning \n\t\tInput:  A dictionary with key as application and value as node on which\n\t\t\t\tthe application is running\n\t\tOutput: Dictionary, key: app, value: overload for the corresponding nodes\n\t\t\t\twhere the app is running \n\t\t\"\"\"\n\t\toverloadNodes = {}\n\t\tfor app,node in dictAppNode:\n\t\t\toverloadNodes[node.getName()]=node.getOverload()\n\t\treturn overloadNodes\n\t\n\tdef overloadListNodes(self,lstNode):\n\t\t\"\"\"\n\t\tDescr : computes overload for a list of nodes  \n\t\tInput : List of Nodes whose overload we need to compute \n\t\tOutput: List containing overload for corresponding nodes\n\t\t\"\"\"\n\t\tlstoverloadNodes = []\n\t\tfor node in lstNode:\n\t\t\tlstoverloadNodes.append(node.getOverload())\n\t\treturn lstoverloadNodes\n\t\n\tdef evaluateNeighbour(self,appToBeEvaluated):\n\t\t\"\"\"\n\t\tDescr  : This function evaluates the all the nodes where application \n\t\t\t\t violates the node constraints \n\t\tInput  : dictionary of app, node \n\t\tOutput : dictionary of possible neighbour nodes for placement for \n\t\t\t\t corresponding application   \n\t\t\"\"\"\n\t\tres = {}\n\t\tfor app,node in appToBeEvaluated:\n\t\t\tlistNodes = node.findNeighbourLocal(node)\n\t\t\toverloadLocalNodes = {}\n\t\t\tfor n in listNodes: \n\t\t\t\tn.resource = n.resource + app.resource\n\t\t\t\toverloadLocalNodes[n] = n.getOverload()\n\t\t\tminNode = min(overloadLocalNodes,key = overloadLocalNodes.get) \n\t\t\t# Node dictionary for placement \n\t\t\tres[app] = minNode\n\t\treturn res \n\t\t\n\t# Schedule an application\n\tdef schedule(self, dictAppNode,thldApp):\n\t\t\"\"\"\n\t\tDescr  : finds the node among the list of the nodes where the \n\t\t\t\t application is migrated based on certain threshold    \n\t\tInput  : dictAppNode: dictionary of (app,Node) to be placed, thldApp\n\t\tOutput : node where the cost of running the app is minimum \n\t\t\"\"\"\n\t\t# compute the overload of the node where the apps are running \n\t\tdictAppNodeOverload = {}\n\t\tappToBeEvaluated = {}\n\t\tfor app,node in dictAppNode:\n\t\t\tdictAppNodeOverload[app] = node.getOverload()\n\t\t\tif dictAppNodeoverload[app] > thldApp[app]:\n\t\t\t\tappToBeEvaluated[app] = node\n\t\t\telse: \n\t\t\t\t# add the app to the node as constraint is fulfilled \n\t\t\t\tnode.resource = node.resource + app.resource\n\t\tpossiblePlacementDict = self.evaluateNeighbour(appToBeEvaluated)\n\t\treturn possiblePlacementDict\n\t\t\n\t\n\t# Notify scheduler of a change in the network\n\tdef notifyScheduler(self): # this needs to contain more inotmation about the change, but for now, it is enough that we send a trigger now.\n\t\tpass","undoManager":{"mark":-1,"position":4,"stack":[[{"group":"doc","deltas":[{"start":{"row":90,"column":0},"end":{"row":154,"column":25},"action":"remove","lines":["\t'''","\t######## Neighbourhood ########","\t'''","\t# [DEPRECATED] What is this for?","\tdef exploreNeighbour(self, node, dist):","\t\t\"\"\"","\t\tcompute all the possible neighbour at fixed distance h","\t\t\"\"\"","\t\tnewDict = {node.getName():{'N_NODE':node,'EDGE':[]}}","\t\td = 0","\t\twhile d< dist: ","\t\t\td = d+1","\t\t\t#print newDict","\t\t\tprint \"----------\"","\t\t\t_temp1 = {}","\t\t\tfor nodeAttributes in newDict.itervalues(): ","\t\t\t\t#print nodeAttributes","\t\t\t\ttempListTuples = nodeAttributes['N_NODE'].getPeersTouple()","\t\t\t\t_temp = {}","\t\t\t\tfor (e,v) in tempListTuples:","\t\t\t\t\t_temp[v.getName()] = {'N_NODE':v,'EDGE':nodeAttributes['EDGE']+[e]}","\t\t\t\t\t#_temp[v.getName()] = {'N_NODE':v,'EDGE':[nodeAttributes['EDGE'],e]}","\t\t\t\t# to add the previous edges","\t\t\t\t_temp1  = dict(_temp.items() + _temp1.items())","\t\t\t\tnewDict =  _temp1","\t\tif node.getName() in newDict:","\t\t\tdel newDict[node.getName()]","\t\tprint \"---result---\"","\t\treturn newDict","\t","\t# [DEPRECATED] What is this for?","\tdef lookupNeighbour(self, node, dist): ","\t\t\"\"\"","\t\treturns all the nodes along with edges (as tuple) at specific distance dist ","\t\t","\t\t\"\"\"","\t\t","\t\tnewDict = {node.getName():{'N_NODE':node,'EDGE':[]}}","\t\td = 0","\t\twhile d<= dist: ","\t\t\td = d+1","\t\t\tprint \"----------\"","\t\t\tfor nodeAttributes in newDict.itervalues(): ","\t\t\t\t#print nodeAttributes","\t\t\t\ttempListTuples = nodeAttributes['N_NODE'].getPeersTouple()","\t\t\t\t_temp = {}","\t\t\t\tfor (e,v) in tempListTuples:","\t\t\t\t\t_temp[v.getName()] = {'N_NODE':v,'EDGE':nodeAttributes['EDGE']+[e]}","\t\t\t\t# to add the previous edges","\t\t\t\t_temp1  = dict(_temp.items() + newDict.items())","\t\t\t\tnewDict =  _temp1","\t\treturn newDict","\t\t","\tdef findNeighbourGlobal(self,dictAppNode):","\t\t\"\"\"","\t\tDescr:  Compute the neighbours if possible, node and link","\t\tInput:  A dictionary with key as application and value as node on which","\t\t\t\tthe application is running ","\t\tOutput: dictionary, key: app, value: all the nodes corresponding to the ","\t\t\t\tnode where the app is running  ","\t\t\"\"\"","\t\tdictAppNeighbour = {}","\t\tfor app,node in dictAppNode:","\t\t\tdictAppNeighbour[app] = node.getChildNodes().append(node.getParentNode())","\t\treturn dictAppNeighbour"]}]}],[{"group":"doc","deltas":[{"start":{"row":89,"column":1},"end":{"row":90,"column":0},"action":"remove","lines":["",""]}]}],[{"group":"doc","deltas":[{"start":{"row":89,"column":1},"end":{"row":90,"column":0},"action":"remove","lines":["",""]}]}],[{"group":"doc","deltas":[{"start":{"row":127,"column":0},"end":{"row":129,"column":2},"action":"remove","lines":["\tdef findNeighbourLocal(self,node): ","\t\treturn node.getChildNodes().append(node.getParentNode())","\t\t"]}]}],[{"group":"doc","deltas":[{"start":{"row":126,"column":1},"end":{"row":127,"column":0},"action":"remove","lines":["",""]}]}]]},"ace":{"folds":[],"scrolltop":2040,"scrollleft":0,"selection":{"start":{"row":15,"column":22},"end":{"row":15,"column":22},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":126,"state":"start","mode":"ace/mode/python"}},"timestamp":1430254697868}